+++
title = "Catching Exceptions"
weight = 4
+++

Before you learn to catch exceptions in your program, you need to see what happens
when you do not catch them. Here is an example which generates an exception.

```
// GenerateException.zen

function main(...arguments)
    var a = 100
    var b = 0
    var c = a / b

    printf('%d / %d = %d\n', a, b, c)
```

When the Zen Virtual Machine tries to evalute `a / b`, it throws an exception
because you tried to divide an integer by zero.

The output of this example is shown here.

```
Exception in thread 'main' zen.core.ArithmeticException: Division by zero
    at GenerateException.main(GenerateException.zen:6)
```

The output contains the type of the exception, an error message and the
stacktrace which points to the location from where the exception occurred.
The stack trace includes the class names, the function names, the file names, and
the line numbers through which the exception propogated.

When an exception is thrown, Zen stops whatever your program is doing and
tries to find an exception handler. In this example, this causes the execution
of the main function to stop. Since we have not provided an exception handler, the
exception propogates outside your function and is caught by the default exception
handler.

Every thread in Zen has a default exception handler which is triggered when an
exception is never caught. In other words, any exception your program fails to
catch is processed by the default exception handler. The default exception handler
prints the exception, the stacktrace from the point where the exception was
thrown, and terminates the current thread. A thread is a component which allows
multiple parts of your program to run simultaneously. In this example, there is
only one thread, hence the program is terminated.

Here is another example which demonstrates how the stacktrace can be useful
to locate the cause of the error.
```
// GenerateException2.zen

function divide(a, b)
    return a / b

function main(...arguments)
    var a = 100
    var b = 0
    var c = divide(a, b)
    printf('%d / %d = %d\n', a, b, c)
```

Here is the output generated by this example.
```
Exception in thread 'main' zen.core.ArithmeticException: Division by zero
    at GenerateException2.divide(GenerateException2.zen:4)
    at GenerateException2.main(GenerateException2.zen:9)
```

As you can see, the stacktrace includes the class name, the function name,
the file name, and the line numbers through which the exception propogated.
The exception can occur in any source file, any class, and any function. This
is why each element in the stacktrace contains these information.
In other words, the stack trace will always show the function invocations which
led up to the error.

## Using the Try and Catch Clauses

You cannot always depend on the default exception handler to handle the exceptions.
In some situations, you will want to handle the exception yourself. With a custom
exception handler, you can resolve the error and prevent the program from terminating.
Imagine, you are writing a server side program. How troublesome would it be if your
program terminated whenever an exception occurred?

You need to monitor a block of code for exceptions using the `try` clause.
You can then provide a custom exception handler using a catch clause.
Whenever you write a `try` clause, you are essentially writing the try statement.
It is a compound statement.

Here is the general form of the try clause.
```
try
    statement1
    statement2
    ...
    statementN
```

A try clause should always be followed by a catch clause or a finally
clause. When both the clauses appear, the finally clause should be the last
clause.

Here is the general form of the catch clause.
```
catch ExceptionType identifier
    statement1
    statement2
    ...
    statementN
```

The `ExceptionType` indicates the type of exception the catch clause handles.
When an exception is caught, the variable identified by `identifier` you
specify holds a reference to the exception object. Basically, you declare a
parameter in the parenthesis of the catch clause. The parameter references the
exception object when the exception is caught.

Here is an example which demonstrates how to catch an exception.
```
// GenerateException3.zen

function divide(a, b)
    return a / b

function main(...arguments)
    var a = 100
    var b = 0
    try
        var c = divide(a, b)
        printf('%d / %d = %d\n', a, b, c)
    catch ArithmeticException exception
        print('Error: You cannot divide an integer by zero.')
```

This example generates the following output.
```
Error: You cannot divide an integer by zero.
```

Notice that the print statement inside the try clause is never executed.
When an exception is thrown, the program stops whatever it is doing.
Zen then tries to find the nearest catch clause in the stack trace.
When a catch clause which anticipates the exception which occurred is found
in the stack trace, the program control jumps out of the try clause and is
transferred to the catch clause. A reference to the exception object is stored
in the parameter of the catch clause. Once the catch clause is done executing,
the statement following the catch clause is executed. The control never returns
back to the location where the exception occurred. Because exceptions are not
like functions to return back.

A catch clause can catch an exception only if one of the statements within the
try clause associated with it throws an exception.